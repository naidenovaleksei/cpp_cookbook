/**
 * 3_3. Количество инверсий.
 * Дана последовательность целых чисел из диапазона (-10^9 .. 10^9). Длина последовательности не больше 10^6. Числа записаны по одному в строке. Количество чисел не указано.
 * Пусть количество элементов n, и числа записаны в массиве a = a[i]: i из [0..n-1].
 * Требуется напечатать количество таких пар индексов (i,j) из [0..n-1], что (i < j и a[i] > a[j]).
 * Указание: количество инверсий может быть больше 4*10^9 - используйте int64_t.
 */
#include <iostream>
#include <cstring>
#include <vector>


/**
 * Склейка массивов с подсчетом инверсий
 * (считаем что первый массив "стоит левее" второго массива)
 * @param a Левый (первый) массив
 * @param n Число элементов в a
 * @param b Правый (второй) массив
 * @param m Число элементов в b
 * @param c Массив-результат
 * @return Число инверсий
 */
int64_t Merge(int *a, int n, int* b, int m, int* c) {
    int64_t counter = 0;
    int i = 0;
    int j = 0;
    // Пока один из массивов не пуст
    while (i < n && j < m) {
        // Выбираем наименьший элемент и добавляем в массив-результат
        if (a[i] <= b[j]) {
            c[i + j] = a[i];
            ++i;
        } else {
            c[i + j] = b[j];
            ++j;
            /* Если наименьший элемент из второго массива, то он меньше всех элементов, оставшихся в первом массиве.
               Прибавляем число оставшихся элементов в счетчик инверсий */
            counter += n - i;
        }
    }
    // Копируем остаток первого массива в конец массива-результата
    if (i < n) memmove(&c[i + j], &a[i], (n - i) * 4);
    // Копируем остаток второго массива в конец массива-результата
    if (j < m) memmove(&c[i + j], &b[j], (m - j) * 4);
    return counter;
}

/**
 * Сортировка массива с подсчетом инверсий
 * @param a Массив
 * @param n Число элементов в массиве
 * @return Число инверсий
 */
int64_t MergeSort( int* a, int n ) {
    if( n <= 1 ) {
        return 0;
    }
    int mid = n / 2;
    // Сортируем левую часть
    int64_t counterLeft = MergeSort( a, mid );
    // Сортируем правую часть
    int64_t counterRight = MergeSort( a + mid, n - mid );
    int* c = new int[n];
    // Склеиваем
    int64_t counter = Merge( a, mid, a + mid, n - mid, c);
    memmove(a, c, n * 4);
    delete[] c;
    // Возвращаем число инверсий, посчитанных в 2 сортировках и склейке
    return counter + counterLeft + counterRight;
}


int main() {
    std::vector<int> data;
    int value;
    while (std::cin >> value) {
        data.push_back(value);
    }
    std::cout << MergeSort(data.data(), data.size());
    return 0;
}


