/**
 * Даны неотрицательные целые числа n,k и массив целых чисел из [0..10^9] размера n.
 * Требуется найти k-ю порядковую статистику. т.е. напечатать число, которое бы стояло на позиции с индексом k (0..n-1) в отсортированном массиве.
 * Напишите нерекурсивный алгоритм. Требования к дополнительной памяти: O(n). Требуемое среднее время работы: O(n).
 * Функцию Partition следует реализовывать методом прохода двумя итераторами в одном направлении. Описание для случая прохода от начала массива к концу:
 * - Реализуйте стратегию выбора опорного элемента “случайный элемент”.
 * - Функцию Partition реализуйте методом прохода двумя итераторами от начала массива к концу.
 */
#include <iostream>
#include <vector>
#include <ctime>
#include <utility>

// Стратегия выбора опорного элемента “случайный элемент”
int SelectReference(int* arr, int n) {
    // Используем текущее время как начальное значение для генератора случайных чисел
    std::srand(unsigned(std::time(0)));
    int index = std::rand() % n;
    return index;
}


int OrderStatistic(int* arr, int n, int k) {
    // "Функция" Partition без рекурсии
    while (1) {
        // Получаем опорный элемент
        int refIndex = SelectReference(arr, n),
                ref = arr[refIndex];
        // Меняем местами последний и опорный элементы
        arr[refIndex] = arr[n - 1];
        arr[n - 1] = ref;
        // Реализация методом прохода двумя итераторами от начала массива к концу.
        int i = 0;
        for (int j = 0; j < n - 1; ++j) {
            // Если j-й элемент небольше опорного, меняем с i-м и инкрементируем i
            if (arr[j] <= ref) {
                if (i != j) std::swap(arr[j], arr[i]);
                ++i;
            }
        }
        // Меняем местами i-й и опорный элементы
        std::swap(arr[i], arr[n-1]);
        // Теперь i-я статистика на i-м месте
        if (i == k) {
            return arr[k];
        } else if (i > k) {
            // Если k слева от опорного элемента, ищем в левой части
            n = i;
        } else {
            // Если k справа от опорного элемента, ищем в правой части
            // Меняем исходные условия для следующего прогона
            arr = &arr[i + 1];
            n -= i + 1;
            k -= i + 1;
        }
    }
}

int main() {
    int n = 0;
    int k = 0;
    std::cin >> n;
    std::cin >> k;
    std::vector<int> data;

    for (int i = 0; i < n; ++i) {
        int value;
        std::cin >> value;
        data.push_back(value);
    }
    std::cout << OrderStatistic(data.data(), data.size(), k);;
    return 0;
}
